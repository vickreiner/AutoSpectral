---
title: "07 Per Cell Optimization"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The aim of this article is to explain a bit more about how we go about optimizing the fluorophore signatures used for unmixing on a per-cell basis in AutoSpectral. Let me know if the explanation doesn't make sense. There are days when I think it's really weird that we can actually figure this stuff out from the data. Also, this is not the only way of doing this, just the best one I've found so far.

Okay, so we're basically going to play some Tetris with your unmixing. You can also think of this as "theme and variations" if you're musically inclined, or multiverse unmixing, if you prefer comics.

The aim here is to deal with the inherent variability that exists in the emissions from the fluorophores. This variability manifests at the level of the cell (or particle/data point) as spread. Spread is a population-level thing; individual cells do not have spread, they have exact positions. We get spread in the unmixing (and compensation in conventional flow) because we have a *distribution* of outcomes in the spillover/spectra for the fluorophores and we unmix using only a single (hopefully) best fit spectrum. This means there are data on both sides of that single best fit (think of it as a median or average for the distribution), both in the raw data and the unmixed. If there is a mismatch between the single-colour control used to generate the fluorophore's spectrum and the actual data in the fully stained sample, this will manifest as a skew in the distribution of the unmixed data (i.e., unmixing error). These mismatches can occur for a multitude of reasons, including tandem breakdown, improperly prepared controls, bead-based controls, low brightness or autofluorescence (AF) contamination of the spectrum. The first part of AutoSpectral--getting the optimized single spectra using `clean.controls()` and `get.fluorophore.spectra()`, gets you as far as it can with a single spectrum per fluorophore. This is the next step.

What we are going to do is similar to what we did with the single cell AF extraction. We will start by mapping the variation in the single-color controls for each fluorophore using a self-organizing map (SOM). 

```{r setup}
library( AutoSpectral )
```

If you haven't already done so, you'll need to run the basic AutoSpectral workflow to get clean spectral signatures and autofluorescence signatures. See the articles on this, including "Single Cell Autofluorescence".

The `af.spectra` here should match the source of your cells in the single-colour controls. If you're using beads for your single colour controls, the `af.spectra` should match the unstained sample that is provided as `AF` in the `control.file`.

For this example, we'll assume you've already run AutoSpectral to extract both your fluorophore signatures and your autofluorescence spectra. This should be quick. For `read.spectra()`, change the name of your files as appropriate. If they aren't in the `table_spectra` folder, change the location using the `spectra.dir` argument.

```{r, eval=FALSE}
asp <- get.autospectral.param( cytometer = "aurora", figures = TRUE )
control.dir <- "./SSC"
control.file <- "fcs_control_file.csv"
spectra <- read.spectra( "Cells AF Removed autospectral spectra.csv" )
af.spectra <- read.spectra( "autospectral autofluorescence.csv" )
```

Now we are ready to go variant hunting.

For the variants, we're going to load in the FCS file for each single-colour control, identify the brightest non-autofluorescent events in the peak channel, and cluster those to get variants.

```{r, eval=FALSE}
variants <- get.spectral.variants(
   control.dir,
   control.file,
   asp,
   spectra,
   af.spectra,
   parallel = TRUE,
   verbose = TRUE 
)
```

Set `parallel` to `TRUE` for faster processing. This should take a couple of minutes.

This outputs a list containing:
1) The thresholds for positivity in each unmixed channel, as determined by the 99.5th percentile on the `AF` sample in `flow.control`. If you refer back to your `control.file`, this will be whichever sample contains "AF" as the fluorophore. This should be an unstained cell control matching the single-colour controls in `control.file` and hence `flow.control`. 2) A named list of matrices, one per fluorophore in `flow.control`. Each matrix contains up to 100 spectra per fluorophore. This number can be adjusted by argument `som.dim` to `get.spectral.variants()`, which is by default `10`.

This is saved as an R object in a .rds file. This will be in the same folder as the output plots, unless you change the specified location using the argument `output.dir`. By default, you should get "Spectral_variants.rds" in folder `figure_spectral_variants`. This can be accessed later using the `readRDS()` base function in R.

The variant spectra are QC'd against the optimized single spectrum for that fluorophore, as defined in `spectra`. If `spectra` don't all look right, neither will the variants. The QC is done by cosine similarity, with a default threshold set to exclude anything less than 0.98.

It's important to bear in mind that we're only allowing variation within the range seen in the single-colour control, nothing more.

We get output plots of the variant signatures, which should appear in the `figure_spectral_variants` folder, unless you change the `output.dir` argument from the default `NULL`.

Here's what BUV661 really looks like, at least on the anti-mouse CD19 BUV661 I used in this experiment:

![BUV661 variability](figures/BUV661_variants.jpg)
The dark blue trace is the optimized single spectrum from `spectra`. The light blue region represents the range of variation across all the variant spectra. Specifically, the min and max for each channel are being plotted.

Notice that the main variation is in the R1 and R2 detectors, indicative of variation in the direct excitation of the red laser-excited acceptor molecule in BUV661. It's hard to get good information about the structure of the Brilliant dyes, but they're long polymers and all except for the shortest emission ones (e.g., BUV395, BV421, BB515 and also BV510) are tandem dyes. BUV661 is probably a tandem of BUV395 and something like Cy5. So, what we are seeing is variation in the ratio of direct Cy5 excitation by the 561nm laser to excitation of BUV395 by the 355nm laser. There are a lot of reasons why this could be happening. One explanation that I consider to be likely is that we have a distribution of species of BUV661 in the conjugated antibody, either due to production variation (not so likely) or tandem breakdown (more likely). When we stain our cells, the distribution of conjugates on any given cell will give a certain result (think of 80 intact molecules and 20 somewhat broken ones on cell A, and perhaps 85:15 on cell B), which will result in a distribution at the population level. There's also electronic noise and measurement error in the mix. Anyway, we get some cells with more red emission and some with less, which will create variability in amount of red signal from BUV661. This means that if we put a fluorophore in our unmixing that uses R1 and/or R2 heavily, say APC, we will observe variability in the cells that are positive for BUV661 with respect to APC. Hence, spillover spread. There are some broader implications here for panel design and other issues in the field, I think.

Here's PE-Vio770 (anti-ACSA-2), which is essentially PE-Cy7. See that there's a wide light blue region around YG1, which is where the base donor PE molecule emits. This means we have some tandem breakdown and that there is a range of species in the vial. The variation in the mid-UV, mid-violet and narrow-blue is AF.

![PE-Vio770 variation](figures/PE-Vio770_variants.jpg)

Okay, now we're ready to unmix with per-cell fluorophore optimization.

This is where we start Tetrising.

We are going to try to figure out which of these variants is the best "fit" for each cell in the data. We do this by trying to fill in the little gaps, the mismatch, in between the raw data and the prediction from the unmixing model. This gap is call the residual, which is the part of the data that cannot be explained by the model. We want the model to be as good as possible, which means minimizing that gap. One way of thinking of the unmixing is that we are trying to squeeze the spectra into the raw data. We can multiply them up and down to scale them, but we don't normally get to change the shapes at all. With the variants, we have options, all of which are very, very similar, but that small flex allows us to fit the shapes in better.

The most accurate way of doing this would be to test not only each variant for each cell, but to test each *combination* of variants, probably in an iterative refinement. Since that would increase at the rate of n.variants^n.fluorophores, it is currently prohibitive to do so. Note that this does not even begin to deal with variation outside the range of what is seen in the single-stained controls. All of this to say, there is probably a better way to do this than a BitCoin-like brute force method. What AutoSpectral currently does is a close approximation by screening all variants simultaneously per cell based on the difference between each variant and the single optimized spectrum. There are other, faster ways of determining the variation in each cell's spectral signatures, but the other options I have tried result in an increase in unmixing-dependent spread due to the carryover of noise.

Anyway, running this in pure R is exceedingly slow. The faster implementation is in C++ and requires installation of `AutoSpectralRcpp`. I strongly encourage you to install that prior to running unmixing as below. Also, be sure that you have the fast BLAS and LAPACK installed. Please reach out if you have suggestions for faster implementation (I'm not a computer scientist).


```{r, eval=FALSE}
library( AutoSpectralRcpp )

fully.stained.dir <- "./Fully stained"

unmix.fcs( fcs.file = file.path( fully.stained.dir, "C3 Lung_GFP_003_Samples.fcs" ),
           spectra = spectra,
           asp = asp,
           flow.control = flow.control,
           method = "AutoSpectral",
           weighted = FALSE,
           af.spectra = lung.af,
           spectra.variants = variants )
```

This will use OLS to find the optimal AF per cell. To use WLS, set `weighted = TRUE`.

Alteratively, we can call `method = "Automatic"`, which is the default. This takes care of the decision making for AF extraction and weighting automatically. So, if you provide `af.spectra`, per-cell AF extraction will be done. Weighting will be used if the data come from the ID7000, the FACSDiscoverS8 or the FACSDiscoverA8, attempting to replicate the methodology used on those systems. For explicit control, call `method = "AutoSpectral"` as above, and set the arguments.

```{r, eval=FALSE}
unmix.fcs( file.path( fully.stained.dir, "C3 Lung_GFP_003_Samples.fcs" ),
           spectra,
           asp,
           flow.control,
           af.spectra = lung.af,
           spectra.variants = variants,
           file.suffix = "perCellOptimized" )
```

Unmixed FCS files will appear in folder `./autospectral_unmixed`.

Add a `file.suffix` argument if you want a tag on the FCS file's name to differentiate it from other versions.


There are three versions of the per-cell fluorophore optimization available in `AutoSpectralRcpp`. These are called using the `speed` argument and are named `fast`, `medium` and `slow`. 

The fast method is the one deployed in R, which is an approximation based on adjusting the predicted values for a fluorophore by its OLS-unmixed abundance and the change in spectra for each variant. This can be calculated in one go for all variants in a matrix. This can be expected to  take in the range of 1 - 7 minutes per FCS file, depending on size, number of detectors and extent of co-positivity for fluorophores (simpler stuff will go faster).

The slow method requires solving the matrix inverse for each variation of the spectral mixing matrix, creating all unmixing matrices and unmixing each cell with each one, as appropriate based on the cell's expression of markers. This can take about 10x as long as the fast method.

The medium method uses Woodbury-Sherman-Morrison rank-one updating to adjust the unmixing matrix for each variant. This is intermediate in speed.

All three versions can produce a reduction in spillover spread, correct for skewing in the data (somewhat) and reduce the dispersion of the negative population. The slower the method, the better it is at dealing with spread above zero.


```{r, eval=FALSE}
unmix.fcs( file.path( fully.stained.dir, "C3 Lung_GFP_003_Samples.fcs" ),
           spectra,
           asp,
           flow.control,
           af.spectra = lung.af,
           spectra.variants = variants,
           file.suffix = "perCellOptimized_slow",
           speed = "slow" )
```

To demonstrate the effectiveness and accuracy of this approach, we created a set of synthetic data. In this 42-colour data set from the Aurora, BUV661 and APC are used to detect CD19 and Foxp3, markers that are not co-expressed. We created a set of data in silico where the raw data for BUV661+ and APC+ events (based on OLS unmixing) were combined or maintained as separate original events. In this way, ground truth is available for BUV661+, APC+ and BUV661+APC+ events. When unmixed using OLS, populations containing BUV661 suffered from misclassification with respect to a positivity threshold for APC set based on a value double that of the 99.5th percentile on the unstained sample. These false positivity errors were reduced when per-cell spectral selection was performed, and the median absolute deviation of ground truth BUV661+APC- events in the APC channel was reduced from 2194 to 723. 

![Synthetic per-cell fluorophore optimization](figures/Synthetic_perCell_fluor.jpg)
Synthetic data showing that per-cell optimization of the fluorophore signatures reduces spillover spread.

Correspondingly, the cosine similarity between the modelâ€™s predictions for BUV661 and the actual data for BUV661 was closer to 1 (identity), consistent with more accurate modelling of the underlying data.

![Matching the underlying spectrum](figures/perCellFluor_similarity.jpg)
Distribution of cosine similarity values between the ground truth and the assigned spectrum for BUV661. Comparison between standard OLS unmixing and AutoSpectral with per-cell fluorophore optimization on synthetic data. Stats by Komogorov-Smirnov test.

